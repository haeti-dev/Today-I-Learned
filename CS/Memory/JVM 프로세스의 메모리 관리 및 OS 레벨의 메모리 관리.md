## **1. JVM 프로세스의 메모리 관리**

### **1) Runtime Data Area**

<img src="https://github.com/user-attachments/assets/e1662525-924d-4bd8-a5e0-9a268b014a06" width="480"/>

**JVM이 프로그램을 실행할 때 사용하는 메모리 공간**을 통칭한다. 크게 Method Area, Stack Area, Heap Area로 구분된다.

1. **Method Area**
    - **역할**: 클래스(혹은 인터페이스) 정보, 상수(상수 풀), static 변수 등의 메타데이터가 저장되는 영역
    - **특징**
        - 앱이 실행되면서 **JVM이 로딩한 클래스 및 인터페이스의 정보가 쌓임**
        - **GC 대상이 되지 않는 영역에 속하는 경우가 많으므로, companion object 등 static 영역에는 무거운 객체를 두지 않는 것이 좋음**
        - 모든 스레드가 공유하여 접근할 수 있음
2. **Stack Area**
    - **역할**: 메서드 호출 시 생성되는 지역 변수, 인자, 리턴값 등이 저장되는 공간
    - **특징**
        - 메서드가 시작되면 스택에 메모리가 할당되고, 메서드가 종료되면 자동으로 해제
        - **각 스레드는 독립된 스택을 사용하므로 스레드 세이프(Thread-safe)가 기본 보장**
        - 원시 타입(기본 자료형)은 값 자체가, 참조 타입(객체)은 **Stack에 참조 주소만** 저장하고, 실**제 객체는 Heap에 생성됨**
        - 안드로이드에서는 스택 메모리 사용량이 시스템에서 자동으로 관리되며, 생성·해제 속도가 빠른 편
3. **Heap Area**
    - **역할**: 프로그램 실행 중 new 등으로 동적으로 생성되는 객체가 저장되는 공간
    - **특징**
        - 가장 많은 메모리를 차지하며, 메모리 할당·해제 비용이 비교적 큼
        - GC(Garbage Collector)가 Heap에 생성된 객체 중 사용되지 않는(참조되지 않는) 객체를 정리해줌
        - **Heap에 있는 객체를 가리키는 참조값이 Stack에 저장되는 구조**

### **2) Garbage Collector(GC)**

**GC**는 “사용되지 않는 객체”를 메모리에서 자동으로 정리하여, **개발자가 명시적으로 해제할 필요가 없게** 해준다.

안드로이드에서는 Dalvik VM(구 버전)과 ART(신 버전)를 통해 GC 알고리즘이 점차 발전해왔다.

1. **Mark-and-Sweep**
    - Dalvik VM(안드로이드 5.0 이전)에서 사용된 기본 방식
    - **동작**:
        1. **Mark**: 루트 객체(스레드 stack 등)부터 연결된 객체를 순회하며 ‘사용 중’으로 표시
        2. **Sweep**: 마킹되지 않은(즉 참조가 끊어진) 객체를 Heap에서 제거
    - **문제점**:
        - **전체 Heap을 한 번에 스캔하므로 Stop-the-world(STW) 시간이 길어, UI 끊김 등의 문제가 발생**
        - 객체가 해제된 자리가 여기저기 흩어져 **“메모리 단편화(fragmentation)”**가 심해질 수 있음(Compact 단계 미비)

1. **Generational GC**
    - 안드로이드 5.0(API 21)부터 ART(Android Runtime)로 전환되면서 도입
    - **세대별(Generation)로 나누어** 관리하는 방식: 새로 생성된 객체가 대부분 수명이 짧다는 전제(Weak Generational Hypothesis)에 기반
    - **Heap 구분**
        - **Young Generation**: 새 객체가 우선 할당되는 공간
            - Young 내에서도 Eden, From Survivor, To Survivor처럼 세부 영역으로 나뉘어 **Minor GC**가 자주 일어남
            - 일정 횟수(Threshold) 이상 살아남은 객체는 Old Generation으로 **승격**
        - **Old Generation**: 비교적 오랫동안 참조되는 객체가 모이는 공간
            - 덩치가 큰 만큼 Young에 비해 GC 횟수는 적지만, 한 번 실행될 때 부담이 큼(= Major GC)
    - **장점**:
        - 새로 생겼다 금방 사라지는 대다수 객체를 소규모(Young) 영역에서 빠르게 정리
        - Old 영역은 변경 가능성이 적으므로, 필요할 때에만 GC 수행

1. **Concurrent Mark-and-Sweep (CMS)**
    - **동시성 GC** 기법 중 하나로, Major GC 시 **STW(Stop-the-world) 시간을 최소화**하기 위해 활용
    - 주요 단계:
        1. Initial Mark & Remark (STW가 있지만 비교적 빠르게 처리)
        2. Concurrent Mark & Sweep (다른 스레드와 병렬 수행)
    - 객체 참조 변화를 추적하기 위해 “Dirty Card” 정보를 활용하기도 함
    - **장점**: 앱이 멈춰 있는 시간이 짧아짐 → **UI/성능 개선**

## **2. OS(Android) 레벨의 메모리 관리**

### **1) 안드로이드 메모리 유형**

1. **RAM**
    - 안드로이드 OS와 앱이 동시에 실행되는 주 메모리
    - 전원이 꺼지면 데이터가 사라지는 휘발성
    - 접근 속도가 빨라 코드 실행이나 런타임 데이터(스택, 힙 객체 등)를 저장하는 데 최적
2. **zRAM**
    - 물리적 RAM 일부를 **압축 스왑 공간**처럼 사용
    - 메모리 부족 시, 우선순위가 낮은 메모리 페이지를 압축해 zRAM 영역에 저장
    - 다시 접근할 때 압축을 해제하여 RAM으로 되돌림
3. **저장소(Internal/External Storage)**
    - 앱 설치 파일, 라이브러리, 시스템 파일 등이 영구적으로 위치하는 공간
    - 용량은 크지만 읽고 쓰는 속도가 RAM 대비 상대적으로 느림

### **2) 메모리 부족 시 동작(커널 스왑 데몬)**

안드로이드 기기는 상대적으로 제한된 메모리를 갖고 있으므로, **사용 가능한 메모리가 임계치 이하**로 떨어지면 여러 방법을 통해 메모리를 확보한다.

1. **메모리 페이지 (Page)**
    - 일반적으로 OS는 **4KB** 단위로 RAM을 나누어 관리(페이지)
    - Free Page(아무도 쓰지 않는 페이지)가 부족해지면, 커널 스레드가 불필요한 페이지를 정리해 Free Page를 늘림
    - 페이지는 크게 **Cached Memory(파일로부터 매핑된 메모리**)와 **Anonymous Memory(파일로 매핑되지 않은 메모리)**로 구분
2. **커널 스왑 데몬**
    - **사용 가능한 메모리가 지정 임계치 이하**가 되면 활성화되어 메모리 정리를 수행
    - **클린 페이지**(변경 사항 없는 페이지)는 그냥 지워버리고, 필요할 때 다시 디스크에서 읽어옴
    - **더티 페이지**(변경된 페이지)는 바로 지울 수 없으므로, 압축(zRAM)하거나 다른 방식으로 스왑아웃
    - 이렇게 확보된 Free Page로 신규 프로세스나 객체가 메모리를 할당할 수 있게 됨
3. **추가적으로 알아두면 좋은 점**
    - **앱 개발 관점**
        - **초기화 비용**이 큰 객체를 자주 생성·파괴하지 않도록 주의
        - Static 영역이나 companion object에는 너무 무거운 리소스를 두지 않는 것이 좋음
        - 메모리 누수가 발생하지 않도록 **Activity/Fragment** 등에서의 참조 해제, 콜백 등록 해제, LiveData 및 LifecycleOwner의 범위 확인 등을 철저히 관리
    - **안드로이드 GC 로그**
        - Logcat에서 GC 로그가 잦으면 성능 문제가 발생할 수 있으므로, 반복적인 큰 객체 생성이나 메모리 할당 패턴을 점검
